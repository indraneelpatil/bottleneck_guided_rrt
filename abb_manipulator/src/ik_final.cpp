/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2019-02-04 19:30:25.593233
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75,x76,x77,x78,x79,x80,x81;
x0=IKsin(j[0]);
x1=IKcos(j[3]);
x2=IKcos(j[0]);
x3=IKsin(j[4]);
x4=IKcos(j[1]);
x5=IKsin(j[2]);
x6=IKcos(j[2]);
x7=IKsin(j[1]);
x8=IKsin(j[3]);
x9=IKcos(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((0.0712401930973299)*x10);
x13=((0.997459186393076)*x3);
x14=((0.9999999968)*x1);
x15=((0.997459189584945)*x10);
x16=((7.9999999744e-5)*x3);
x17=((1.0)*x1);
x18=((0.76)*x0);
x19=((0.0712401930973299)*x11);
x20=((0.0712401928693612)*x9);
x21=((0.01)*x4);
x22=((5.119999967232e-10)*x0);
x23=((7.9999999744e-5)*x9);
x24=((0.76)*x2);
x25=((0.079999999488)*x9);
x26=((1.0)*x0);
x27=((0.0712401928693612)*x3);
x28=((0.997459189584945)*x11);
x29=((0.997459186393076)*x9);
x30=((1.0)*x2);
x31=((0.079999999488)*x3);
x32=((5.119999967232e-10)*x1);
x33=((5.119999967232e-10)*x2);
x34=(x2*x8);
x35=(x0*x8);
x36=(x1*x3);
x37=(x5*x7);
x38=((-7.9999999744e-5)*x9);
x39=(x4*x6);
x40=(x4*x5);
x41=(x0*x7);
x42=(x0*x1);
x43=(x1*x2);
x44=(x6*x7);
x45=((-1.0)*x1);
x46=((-7.9999999744e-5)*x3);
x47=(x26*x8);
x48=(x2*x44);
x49=(x30*x39);
x50=(x26*x39);
x51=((((-1.0)*x37))+x39);
x52=(x44+x40);
x53=((((-0.9999999968)*x37))+(((0.9999999968)*x39)));
x54=((((-7.9999999744e-5)*x37))+(((7.9999999744e-5)*x39)));
x55=(x1*x51);
x56=(x23*x52);
x57=(x53*x8);
x58=(x54*x8);
x59=((((-1.0)*x49))+((x2*x37)));
x60=(((x2*x40))+x48);
x61=(((x0*x37))+(((-1.0)*x50)));
x62=(((x41*x6))+((x0*x40)));
x63=(x36*x51);
x64=(x16*x55);
x65=(x30*(((((-1.0)*x40))+(((-1.0)*x44)))));
x66=(x26*(((((-1.0)*x40))+(((-1.0)*x44)))));
x67=(x62*x8);
x68=(x59*x9);
x69=(x60*x8);
x70=(x1*x65);
x71=(x47+(((-1.0)*x17*x65)));
x72=((((-1.0)*x17*x66))+(((-1.0)*x30*x8)));
x73=(((x3*(((((-1.0)*x40))+(((-1.0)*x44))))))+((x55*x9)));
x74=(x56+x64);
x75=(x3*x72);
x76=(x74+x57);
x77=(((x71*x9))+((x3*(((((-1.0)*x30*x37))+x49)))));
x78=(((x72*x9))+((x3*((x50+(((-1.0)*x26*x37)))))));
x79=(((x16*x71))+(((-0.9999999968)*x42))+(((0.9999999968)*x69))+((x23*x59)));
x80=(((x23*x61))+((x16*x72))+((x14*x2))+(((0.9999999968)*x67)));
x81=(x10*x80);
eerot[0]=((((5.6992154295489e-6)*x42))+((x20*x59))+(((-5.6992154295489e-6)*x69))+((x28*x77))+((x27*x71))+((x15*x79)));
eerot[1]=(((x10*x77))+((x11*((((x38*x59))+((x0*x14))+((x46*x71))+(((-0.9999999968)*x69)))))));
eerot[2]=((((-1.0)*x29*x59))+((x19*x77))+(((-7.9796734911446e-5)*x42))+((x12*x79))+(((7.9796734911446e-5)*x69))+(((-1.0)*x13*x71)));
IkReal x82=((1.0)*x37);
IkReal x83=(x2*x40);
eetrans[0]=((((0.65)*x2*x7))+(((6.39999995904e-6)*x69))+(((0.12)*x48))+((x3*((((x32*x65))+(((-1.0)*x22*x8))))))+((x9*(((((-1.0)*x33*x82))+((x33*x39))))))+(((0.15)*x2))+((x8*(((((-6.39999995904e-6)*x83))+(((-6.39999995904e-6)*x48))))))+(((-1.0)*x2*x21))+(((0.12)*x83))+((x1*(((((0.02)*x83))+(((0.02)*x48))))))+(((0.02)*x35))+(((8.470329472543e-22)*x42))+((x24*x39))+(((-1.0)*x24*x82))+(((-1.0)*x25*x59))+(((-1.0)*x31*((((x45*x65))+x47)))));
eerot[3]=(((x20*x61))+(((-5.6992154295489e-6)*x67))+((x15*x80))+((x28*x78))+((x27*x72))+(((-5.6992154295489e-6)*x43)));
eerot[4]=(((x10*x78))+((x11*((((x38*x61))+((x46*x72))+(((-0.9999999968)*x67))+(((-0.9999999968)*x43)))))));
eerot[5]=(((x12*x80))+(((-1.0)*x29*x61))+((x19*x78))+(((7.9796734911446e-5)*x43))+(((7.9796734911446e-5)*x67))+(((-1.0)*x13*x72)));
IkReal x84=(x0*x40);
IkReal x85=(x41*x6);
IkReal x86=((1.0)*x37);
eetrans[1]=((((6.39999995904e-6)*x67))+(((-1.0)*x25*x61))+((x8*(((((-6.39999995904e-6)*x84))+(((-6.39999995904e-6)*x85))))))+(((-8.470329472543e-22)*x43))+((x3*((((x33*x8))+((x32*x66))))))+(((-1.0)*x0*x21))+((x18*x39))+(((0.15)*x0))+(((0.12)*x85))+(((0.12)*x84))+(((-0.02)*x34))+(((0.65)*x41))+((x1*(((((0.02)*x85))+(((0.02)*x84))))))+(((-1.0)*x31*(((((-1.0)*x34))+((x45*x66))))))+(((-1.0)*x18*x86))+((x9*((((x22*x39))+(((-1.0)*x22*x86)))))));
eerot[6]=(((x27*x55))+((x20*x52))+(((-0.0712401930973299)*x58))+((x28*x73))+((x15*x76)));
eerot[7]=(((x10*x73))+((x11*(((((-1.0)*x74))+(((-1.0)*x57)))))));
eerot[8]=((((0.997459189584945)*x58))+(((-1.0)*x29*x52))+((x19*x73))+((x12*x76))+(((-1.0)*x13*x55)));
eetrans[2]=((0.54)+(((0.12)*x39))+(((-0.76)*x44))+(((-0.76)*x40))+(((0.079999999744)*x58))+(((0.65)*x4))+((x36*(((((5.119999967232e-10)*x37))+(((-5.119999967232e-10)*x39))))))+(((-1.0)*x31*x55))+(((-0.12)*x37))+((x1*(((((-0.02)*x37))+(((0.02)*x39))))))+((x9*(((((-5.119999967232e-10)*x44))+(((-5.119999967232e-10)*x40))))))+((x8*(((((-6.39999995904e-6)*x39))+(((6.39999995904e-6)*x37))))))+(((0.01)*x7))+(((-1.0)*x25*x52)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((((0.997459189584945)*r00))+(((0.0712401930973299)*r02)));
new_r01=r01;
new_r02=((((-0.0712401930973299)*r00))+(((0.997459189584945)*r02)));
new_px=((((-0.0797967349114461)*r02))+px+(((0.0056992154295489)*r00)));
new_r10=((((0.997459189584945)*r10))+(((0.0712401930973299)*r12)));
new_r11=r11;
new_r12=((((-0.0712401930973299)*r10))+(((0.997459189584945)*r12)));
new_py=((((-0.0797967349114461)*r12))+py+(((0.0056992154295489)*r10)));
new_r20=((((0.997459189584945)*r20))+(((0.0712401930973299)*r22)));
new_r21=r21;
new_r22=((((0.997459189584945)*r22))+(((-0.0712401930973299)*r20)));
new_pz=((-0.54)+(((0.0056992154295489)*r20))+(((-0.0797967349114461)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x87=((1.0)*px);
IkReal x88=((1.0)*pz);
IkReal x89=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x89))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x88)));
rxp0_2=((((-1.0)*r10*x87))+((py*r00)));
rxp1_0=((((-1.0)*r21*x89))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x88)));
rxp1_2=((((-1.0)*r11*x87))+((py*r01)));
rxp2_0=((((-1.0)*r22*x89))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x88))+((px*r22)));
rxp2_2=((((-1.0)*r12*x87))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x90=((7.9999999744e-5)*rxp0_2);
IkReal x91=((0.9999999968)*rxp2_2);
IkReal x92=((1.59999999488e-6)*r22);
IkReal x93=((6.39999995904e-6)*r21);
IkReal x94=((0.019999999936)*r20);
IkReal x95=((0.00013439999956992)*npx);
IkReal x96=((0.00479999998464)*r10);
IkReal x97=((1.519999995136)*npz);
IkReal x98=((0.3)*px);
IkReal x99=((0.006)*r01);
IkReal x100=((1.5359999901696e-6)*r11);
IkReal x101=((0.0359999998848)*r22);
IkReal x102=((2.879999990784e-6)*r20);
IkReal x103=((0.2279999992704)*r02);
IkReal x104=((0.239999999232)*rxp2_1);
IkReal x105=((2.0159999935488e-5)*r00);
IkReal x106=((0.04)*npy);
IkReal x107=((1.919999993856e-5)*rxp0_1);
IkReal x108=((1.0)*pp);
IkReal x109=((3.839999987712e-7)*r12);
IkReal x110=((0.239999999232)*rxp2_0);
IkReal x111=((0.3)*py);
IkReal x112=((0.006)*r11);
IkReal x113=((1.919999993856e-5)*rxp0_0);
IkReal x114=((3.839999987712e-7)*r02);
IkReal x115=((0.2279999992704)*r12);
IkReal x116=((0.00479999998464)*r00);
IkReal x117=((2.0159999935488e-5)*r10);
IkReal x118=((1.5359999901696e-6)*r01);
IkReal x119=((3.839999987712e-5)*rxp1_1);
IkReal x120=((0.08)*npx);
IkReal x121=((3.0719999803392e-6)*r10);
IkReal x122=((0.012)*r00);
IkReal x123=((0.00026879999913984)*npy);
IkReal x124=((4.0319999870976e-5)*r01);
IkReal x125=((5.759999981568e-6)*r21);
IkReal x126=((0.00959999996928)*r11);
IkReal x127=((4.0)*rxp0_2);
IkReal x128=((2.0)*rxp1_2);
IkReal x129=((1.279999995904e-5)*r22);
IkReal x130=((9.59999996928e-7)*r00);
IkReal x131=((0.456)*r01);
IkReal x132=((0.48)*rxp1_1);
IkReal x133=((0.0119999999616)*r02);
IkReal x134=((3.0719999901696e-6)*r12);
IkReal x135=((0.072)*r21);
IkReal x136=((6.39999997952e-6)*npx);
IkReal x137=((3.04)*npy);
IkReal x138=((0.079999999744)*npz);
IkReal x139=((0.456)*r11);
IkReal x140=((9.59999996928e-7)*r10);
IkReal x141=((0.0119999999616)*r12);
IkReal x142=((0.48)*rxp1_0);
IkReal x143=((3.0719999901696e-6)*r02);
IkReal x144=((0.96)*rxp0_1);
IkReal x145=((6.08)*npx);
IkReal x146=((0.144)*r20);
IkReal x147=((0.912)*r00);
IkReal x148=((1.279999995904e-5)*npy);
IkReal x149=((1.919999993856e-6)*r01);
IkReal x150=((1.279999991808e-5)*r20);
IkReal x151=((0.000159999999488)*rxp1_2);
IkReal x152=((0.039999999872)*r21);
IkReal x153=((0.012)*r10);
IkReal x154=((3.839999987712e-5)*rxp1_0);
IkReal x155=((3.0719999803392e-6)*r00);
IkReal x156=((0.00959999996928)*r01);
IkReal x157=((1.6319999947776e-5)*r00);
IkReal x158=((0.00010879999965184)*npx);
IkReal x159=((1.6319999947776e-5)*r10);
IkReal x160=((3.2639999895552e-5)*r01);
IkReal x161=((0.00021759999930368)*npy);
IkReal x162=((((-1.0)*x129))+x128);
IkReal x163=((((-1.0)*x129))+(((-1.0)*x128)));
IkReal x164=(x105+x106);
IkReal x165=(x93+x92);
IkReal x166=(x90+x92);
IkReal x167=(x113+x112);
IkReal x168=(x158+x102);
IkReal x169=(x157+x96);
IkReal x170=(x111+x114);
IkReal x171=(x159+x118);
IkReal x172=(x109+x107);
IkReal x173=(x140+x139);
IkReal x174=(x109+x106);
IkReal x175=(x134+x133);
IkReal x176=(x91+x94);
IkReal x177=(x155+x154);
IkReal x178=(x144+x147);
IkReal x179=(x145+x146);
IkReal x180=(x101+x97);
IkReal x181=(x108+x98);
IkReal x182=(x151+x150);
IkReal x183=(x125+x120);
IkReal x184=(x100+x99);
IkReal x185=((((-1.0)*x152))+x182);
IkReal x186=((((0.96)*rxp0_0))+(((1.919999993856e-6)*r11))+(((-0.912)*r10)));
IkReal x187=((-0.19229999926272)+x184);
IkReal x188=((-0.1923000008192)+x104+x103);
IkReal x189=((((-1.0)*x152))+(((-1.0)*x182)));
IkReal x190=(x108+x104+x103);
IkReal x191=(x135+x137+x136);
IkReal x192=(x104+x103+x98);
IkReal x193=(x117+x116+x118);
IkReal x194=(x105+x102+x95);
IkReal x195=(x184+x96);
IkReal x196=(x131+x130+x132);
IkReal x197=(x107+x180+x98);
IkReal x198=(x124+x122+x121+x119);
IkReal x199=(x176+x165+(((-1.0)*x90)));
IkReal x200=(x166+x91+(((-1.0)*x93))+(((-1.0)*x94)));
IkReal x201=((((-1.0)*x153))+(((-1.0)*x156))+x177+(((-4.0319999870976e-5)*r11)));
IkReal x202=((((-1.0)*x143))+(((-1.0)*x173))+x141+x142);
IkReal x203=((((-1.0)*x143))+(((-1.0)*x142))+x173+x141);
IkReal x204=(x166+x94+(((-1.0)*x93))+(((-1.0)*x91)));
IkReal x205=((((-1.0)*x176))+x165+(((-1.0)*x90)));
IkReal x206=((((-1.0)*x156))+(((3.2639999895552e-5)*r11))+(((-1.0)*x177))+x153);
IkReal x207=(x175+x196);
IkReal x208=(x102+x195+x95);
IkReal x209=(x160+x126+x122+x121+x119);
IkReal x210=((((-1.0)*x167))+(((-1.0)*x115))+x170+x110+x193);
IkReal x211=((((-1.0)*x193))+(((-1.0)*x115))+x170+x167+x110);
IkReal x212=((((-1.0)*x171))+(((-1.0)*x110))+x170+x167+x116+x115);
IkReal x213=((((-1.0)*x167))+(((-1.0)*x116))+(((-1.0)*x110))+x171+x170+x115);
op[0]=x199;
op[1]=x199;
op[2]=x185;
op[3]=x185;
op[4]=x200;
op[5]=x200;
op[6]=((-0.1923000008192)+(((-1.0)*x109))+(((-1.0)*x190))+x164+x197+(((-1.0)*x208)));
op[7]=x210;
op[8]=((((-1.0)*x198))+x126+x123+x183);
op[9]=x201;
op[10]=((-0.1923000008192)+(((-1.0)*x164))+(((-1.0)*x172))+(((-1.0)*x190))+x180+x208+x98);
op[11]=x211;
op[12]=x210;
op[13]=((((-1.0)*x181))+(((-1.0)*x107))+(((-1.0)*x194))+x174+x195+x180+x188);
op[14]=x201;
op[15]=((((-1.0)*x126))+x123+x198+x183);
op[16]=x211;
op[17]=((((-1.0)*x181))+(((-1.0)*x106))+(((-1.0)*x195))+x172+x194+x180+x188);
op[18]=0;
op[19]=x199;
op[20]=0;
op[21]=x185;
op[22]=0;
op[23]=x200;
op[24]=x162;
op[25]=x162;
op[26]=x127;
op[27]=x127;
op[28]=x163;
op[29]=x163;
op[30]=((4.0959999737856e-11)+(((-1.0)*x196))+x175+x191+(((-1.0)*x138)));
op[31]=x202;
op[32]=((((-1.0)*x148))+(((-1.0)*x178))+x179+x149);
op[33]=x186;
op[34]=((4.0959999737856e-11)+(((-1.0)*x191))+(((-1.0)*x138))+x207);
op[35]=x203;
op[36]=x202;
op[37]=((4.0959999737856e-11)+(((-1.0)*x175))+x191+x196+(((-1.0)*x138)));
op[38]=x186;
op[39]=((((-1.0)*x149))+(((-1.0)*x148))+x179+x178);
op[40]=x203;
op[41]=((4.0959999737856e-11)+(((-1.0)*x191))+(((-1.0)*x207))+(((-1.0)*x138)));
op[42]=0;
op[43]=x162;
op[44]=0;
op[45]=x127;
op[46]=0;
op[47]=x163;
op[48]=x204;
op[49]=x204;
op[50]=x189;
op[51]=x189;
op[52]=x205;
op[53]=x205;
op[54]=((((-1.0)*x169))+(((-1.0)*x172))+(((-1.0)*x180))+(((-1.0)*x108))+(((-1.0)*x106))+x168+x192+x187);
op[55]=x212;
op[56]=((((-1.0)*x161))+(((-1.0)*x183))+x209);
op[57]=x206;
op[58]=((-0.19229999926272)+(((-1.0)*x168))+(((-1.0)*x180))+(((-1.0)*x184))+(((-1.0)*x109))+(((-1.0)*x108))+x169+x106+x107+x192);
op[59]=x213;
op[60]=x212;
op[61]=((-0.19229999926272)+(((-1.0)*x180))+(((-1.0)*x184))+(((-1.0)*x181))+(((-1.0)*x106))+(((-1.0)*x104))+(((-1.0)*x103))+x172+x168+x169);
op[62]=x206;
op[63]=((((-1.0)*x161))+(((-1.0)*x183))+(((-1.0)*x209)));
op[64]=x213;
op[65]=((((-1.0)*x169))+(((-1.0)*x168))+(((-1.0)*x180))+(((-1.0)*x181))+(((-1.0)*x107))+(((-1.0)*x104))+(((-1.0)*x103))+x174+x187);
op[66]=0;
op[67]=x204;
op[68]=0;
op[69]=x189;
op[70]=0;
op[71]=x205;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x214=htj4*htj4;
CheckValue<IkReal> x215=IKPowWithIntegerCheck(((1.0)+x214),-1);
if(!x215.valid){
continue;
}
cj4array[numsolutions]=((x215.value)*(((1.0)+(((-1.0)*x214)))));
CheckValue<IkReal> x216=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x216.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x216.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x217=htj5*htj5;
CheckValue<IkReal> x218=IKPowWithIntegerCheck(((1.0)+x217),-1);
if(!x218.valid){
continue;
}
cj5array[numsolutions]=((x218.value)*(((1.0)+(((-1.0)*x217)))));
CheckValue<IkReal> x219=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x219.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x219.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x220=htj0*htj0;
CheckValue<IkReal> x221=IKPowWithIntegerCheck(((1.0)+x220),-1);
if(!x221.valid){
continue;
}
cj0array[numsolutions]=((x221.value)*(((1.0)+(((-1.0)*x220)))));
CheckValue<IkReal> x222=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x222.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x222.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[2];
IkReal x223=(cj4*r02);
IkReal x224=(cj4*r01*sj5);
IkReal x225=(cj4*cj5*r00);
IkReal x226=(r00*sj4*sj5);
IkReal x227=(cj5*r01*sj4);
j3eval[0]=(x225+(((-12500.0)*x223))+(((-12500.00004)*x227))+(((-12500.00004)*x226))+(((-1.0)*x224)));
j3eval[1]=IKsign(((((-7.9999999744e-5)*x224))+(((-0.9999999968)*x223))+(((7.9999999744e-5)*x225))+(((-1.0)*x226))+(((-1.0)*x227))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x228=(cj4*r12);
IkReal x229=(cj4*cj5*r10);
IkReal x230=(r10*sj4*sj5);
IkReal x231=(cj4*r11*sj5);
IkReal x232=(cj5*r11*sj4);
j3eval[0]=((((-12500.00004)*x232))+(((-12500.00004)*x230))+x229+(((-12500.0)*x228))+(((-1.0)*x231)));
j3eval[1]=IKsign(((((-0.9999999968)*x228))+(((-7.9999999744e-5)*x231))+(((-1.0)*x232))+(((-1.0)*x230))+(((7.9999999744e-5)*x229))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x233=(cj4*r22);
IkReal x234=(cj4*r21*sj5);
IkReal x235=(r20*sj4*sj5);
IkReal x236=(cj4*cj5*r20);
IkReal x237=(cj5*r21*sj4);
j3eval[0]=(x234+(((12500.00004)*x237))+(((12500.00004)*x235))+(((12500.0)*x233))+(((-1.0)*x236)));
j3eval[1]=IKsign(((((0.9999999968)*x233))+(((7.9999999744e-5)*x234))+x237+x235+(((-7.9999999744e-5)*x236))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x238=(cj0*r01);
IkReal x239=((1.0)*cj4);
IkReal x240=((7.9999999744e-5)*sj0);
IkReal x241=(cj5*sj4);
IkReal x242=(sj4*sj5);
IkReal x243=((7.9999999744e-5)*cj0);
IkReal x244=(sj0*sj5);
IkReal x245=((0.9999999968)*cj0);
IkReal x246=(cj5*sj0);
IkReal x247=((7.9999999744e-5)*cj4);
CheckValue<IkReal> x248=IKPowWithIntegerCheck(IKsign(((((0.9999999968)*cj4*r22))+((r21*((((sj5*x247))+x241))))+((r20*(((((-1.0)*cj5*x247))+x242)))))),-1);
if(!x248.valid){
continue;
}
CheckValue<IkReal> x249 = IKatan2WithCheck(IkReal(((((-0.9999999968)*r10*x246))+(((0.9999999968)*sj5*x238))+(((-1.0)*cj5*r00*x245))+(((-1.0)*r12*x240))+(((0.9999999968)*r11*x244))+(((-1.0)*r02*x243)))),IkReal(((((0.9999999968)*r12*sj0*sj4))+(((-1.0)*cj0*r00*sj5*x239))+((r02*sj4*x245))+(((-1.0)*r10*x240*x241))+((r11*x240*x242))+(((7.9999999744e-5)*x238*x242))+(((-1.0)*r11*x239*x246))+(((-1.0)*cj5*x238*x239))+(((-1.0)*r10*x239*x244))+(((-1.0)*r00*x241*x243)))),IKFAST_ATAN2_MAGTHRESH);
if(!x249.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x248.value)))+(x249.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x250=IKsin(j3);
IkReal x251=IKcos(j3);
IkReal x252=((7.9999999744e-5)*cj5);
IkReal x253=((7.9999999744e-5)*sj5);
IkReal x254=(sj4*x250);
IkReal x255=(cj4*x250);
IkReal x256=((0.9999999968)*x251);
IkReal x257=((7.9999999744e-5)*x251);
evalcond[0]=((((-1.0)*cj5*r20*x256))+(((-1.0)*r22*x257))+((cj5*r21*x255))+(((-0.9999999968)*r22*x254))+((r21*sj5*x256))+((r20*x252*x254))+((r20*sj5*x255))+(((-1.0)*r21*x253*x254)));
evalcond[1]=((((-1.0)*r11*x253*x254))+cj0+((cj5*r11*x255))+((r10*sj5*x255))+(((-1.0)*r12*x257))+(((-1.0)*cj5*r10*x256))+((r11*sj5*x256))+(((-0.9999999968)*r12*x254))+((r10*x252*x254)));
evalcond[2]=((((-1.0)*sj0))+((r00*sj5*x255))+(((-1.0)*r02*x257))+(((-1.0)*r01*x253*x254))+((r01*sj5*x256))+((cj5*r01*x255))+(((-1.0)*cj5*r00*x256))+(((-0.9999999968)*r02*x254))+((r00*x252*x254)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x258=((0.02)*cj4);
IkReal x259=((7.9999999744e-5)*cj4);
IkReal x260=(sj4*sj5);
IkReal x261=(cj5*sj4);
IkReal x262=((0.9999999968)*cj4*r02);
IkReal x263=((6.39999997952e-6)*r21*sj5);
IkReal x264=(cj5*r00*x259);
IkReal x265=((1.0)*r01*x261);
IkReal x266=((1.0)*r00*x260);
IkReal x267=(r01*sj5*x259);
IkReal x268=(cj5*r21*x258);
IkReal x269=(r20*sj5*x258);
IkReal x270=((1.59999999488e-6)*r20*x261);
IkReal x271=((((0.019999999936)*r22*sj4))+(((1.59999999488e-6)*r21*x260))+(((6.39999997952e-6)*cj5*r20))+(((1.0)*pz)));
IkReal x272=(x263+x269+x268+x270);
IkReal x273=(x265+x267+x266+x262);
IkReal x274=(cj0+x264+(((-1.0)*x273)));
IkReal x275=(x264+(((-1.0)*x273))+(((-1.0)*cj0)));
IkReal x276=((0.77)+x272+(((-1.0)*x271)));
IkReal x277=((0.53)+x272+(((-1.0)*x271)));
IkReal x278=((-0.77)+x272+(((-1.0)*x271)));
IkReal x279=((-0.53)+x272+(((-1.0)*x271)));
IkReal gconst0=x274;
IkReal gconst1=x275;
IkReal gconst2=x276;
IkReal gconst3=x277;
IkReal gconst4=x274;
IkReal gconst5=x275;
IkReal gconst6=x276;
IkReal gconst7=x277;
IkReal gconst8=x275;
IkReal gconst9=x274;
IkReal gconst10=x278;
IkReal gconst11=x279;
IkReal gconst12=x275;
IkReal gconst13=x274;
IkReal gconst14=x278;
IkReal gconst15=x279;
IkReal x280=cj0*cj0;
IkReal x281=((1.54)*gconst4);
IkReal x282=(gconst0*gconst3);
IkReal x283=(gconst6*gconst9);
IkReal x284=((1.92)*cj0);
IkReal x285=(gconst10*gconst9);
IkReal x286=((1.54)*gconst14);
IkReal x287=(gconst13*gconst8);
IkReal x288=((6.08)*cj0);
IkReal x289=(gconst12*gconst3);
IkReal x290=((1.5)*gconst5);
IkReal x291=((1.54)*gconst12);
IkReal x292=(gconst0*gconst5);
IkReal x293=(gconst0*gconst12);
IkReal x294=(gconst11*gconst14);
IkReal x295=(gconst0*gconst13);
IkReal x296=(gconst2*gconst9);
IkReal x297=(gconst11*gconst6);
IkReal x298=(gconst15*gconst4);
IkReal x299=(gconst1*gconst10);
IkReal x300=((1.0)*gconst11);
IkReal x301=(gconst1*gconst12);
IkReal x302=(gconst12*gconst7);
IkReal x303=((2.25)*gconst5);
IkReal x304=(gconst0*gconst15);
IkReal x305=(gconst1*gconst6);
IkReal x306=(gconst12*gconst15);
IkReal x307=(cj0*gconst4);
IkReal x308=((1.5)*gconst11);
IkReal x309=(gconst3*gconst4);
IkReal x310=(gconst4*gconst7);
IkReal x311=(gconst13*gconst14);
IkReal x312=((2.88)*cj0);
IkReal x313=((1.5)*gconst13);
IkReal x314=((2.25)*gconst13);
IkReal x315=((2.3716)*gconst4);
IkReal x316=((1.5)*gconst9);
IkReal x317=((1.5)*gconst1);
IkReal x318=(gconst11*gconst4);
IkReal x319=(gconst11*gconst8);
IkReal x320=((1.54)*gconst8);
IkReal x321=((2.3104)*gconst4);
IkReal x322=(gconst15*gconst8);
IkReal x323=(gconst5*gconst8);
IkReal x324=(gconst0*gconst11);
IkReal x325=(gconst14*gconst9);
IkReal x326=(gconst12*gconst9);
IkReal x327=(gconst11*gconst12);
IkReal x328=((1.54)*gconst6);
IkReal x329=(gconst1*gconst2);
IkReal x330=(gconst1*gconst14);
IkReal x331=((1.0)*gconst5);
IkReal x332=(gconst5*gconst6);
IkReal x333=(gconst7*gconst8);
IkReal x334=((1.0)*gconst13);
IkReal x335=(cj0*gconst12);
IkReal x336=(gconst3*gconst6);
IkReal x337=(gconst0*gconst7);
IkReal x338=(gconst14*gconst3);
IkReal x339=((9.12)*cj0);
IkReal x340=(gconst3*gconst8);
IkReal x341=((2.0804)*gconst4);
IkReal x342=((1.4592)*gconst4);
IkReal x343=((1.4592)*x326);
IkReal x344=((9.3632)*x335);
IkReal x345=((2.3104)*x326);
IkReal x346=(gconst9*x339);
IkReal x347=(gconst9*x342);
IkReal x348=((1.4592)*x301);
IkReal x349=((9.3632)*x307);
IkReal x350=((2.3104)*x301);
IkReal x351=(gconst1*x339);
IkReal x352=(gconst9*x321);
IkReal x353=(gconst1*x342);
IkReal x354=(gconst1*x321);
IkReal x355=(gconst2*x331);
IkReal x356=((24.64)*x280);
IkReal x357=((16.0)*x280);
IkReal x358=((24.0)*x280);
IkReal x359=(x288*x325);
IkReal x360=(x288*x327);
IkReal x361=(x288*x318);
IkReal x362=(x288*x330);
IkReal x363=(x283*x288);
IkReal x364=(x288*x289);
IkReal x365=(x288*x309);
IkReal x366=(x288*x305);
IkReal x367=(gconst14*x357);
IkReal x368=(x347+x348);
IkReal x369=(x350+x352);
IkReal x370=(x359+x360);
IkReal x371=(x365+x366);
IkReal x372=(x361+x362+x363+x364);
op[0]=((((-1.0)*gconst8*x300*x306))+((x285*x306))+((x287*x294))+(((-1.0)*x285*x311))+(((-1.0)*x345)));
op[1]=((((-1.0)*x291*x319))+((x286*x287))+((x285*x313))+(((-1.0)*x370))+(((-1.0)*x287*x308))+x343+(((-1.0)*x306*x316))+((x285*x291))+((x311*x316))+(((-1.0)*x291*x322)));
op[2]=((((-1.0)*gconst8*x300*x302))+(((-1.0)*x296*x311))+(((2.0804)*x326))+((x285*x302))+(((-1.0)*gconst14*x285*x331))+(((-1.0)*x369))+(((-1.0)*x289*x322))+(((-1.0)*x299*x311))+(((-1.0)*gconst10*x283*x334))+((x287*x297))+((x287*x338))+((x299*x306))+x346+(((-2.31)*x287))+((x285*x298))+(((-1.0)*x294*x357))+(((-1.0)*gconst9*x314))+(((-1.0)*gconst15*x293*x300))+((x296*x306))+((x284*x327))+((x284*x325))+(((-1.0)*gconst8*x298*x300))+((x294*x295))+((x294*x323))+(((-1.0)*x344))+(((-2.3716)*gconst12*gconst8)));
op[3]=((((-1.0)*gconst14*x356))+((x291*x299))+((x291*x296))+((x290*x325))+(((-1.0)*x281*x322))+(((-1.0)*x289*x320))+(((-1.0)*x290*x319))+(((2.9568)*x335))+(((-1.0)*x291*x333))+(((-1.5)*gconst15*x301))+(((-1.0)*x372))+((x296*x313))+(((-1.0)*x281*x319))+(((-1.0)*x302*x316))+((x299*x313))+((x287*x328))+((x283*x313))+(((-1.0)*x295*x308))+(((-1.5)*gconst3*x287))+x370+x368+((x286*x323))+((x285*x290))+((x286*x295))+(((-1.0)*gconst9*x312))+((x311*x317))+(((-1.0)*x343))+(((-1.0)*x298*x316))+((x281*x285))+((gconst11*x358))+(((-1.0)*x291*x324))+(((-1.0)*x291*x304)));
op[4]=((((36.96)*x280))+((x284*x289))+(((-1.0)*x298*x340))+((gconst15*gconst2*x301))+(((-1.0)*gconst0*x298*x300))+(((-1.0)*gconst8*x300*x310))+(((-1.0)*gconst1*x314))+(((-2.3716)*x293))+(((-1.0)*x289*x333))+((x284*x330))+((x285*x310))+(((-1.0)*gconst14*x296*x331))+(((-1.0)*x354))+(((-1.0)*gconst7*x293*x300))+(((-1.0)*gconst10*x283*x331))+(((-2.31)*x323))+(((-1.0)*x338*x357))+((x287*x336))+((x299*x302))+((x284*x318))+x351+x344+((x298*x299))+((x282*x311))+((x295*x297))+((x297*x323))+(((-1.0)*gconst8*x315))+((x296*x302))+(((-1.0)*gconst6*x299*x334))+((x296*x298))+(((-1.0)*gconst9*x303))+((x323*x338))+(((-1.0)*x282*x306))+(((-1.0)*x345))+(((-1.0)*x346))+(((-1.0)*x349))+(((-1.0)*x311*x329))+(((-1.0)*x297*x357))+((gconst9*x341))+(((2.0804)*x301))+((x292*x294))+(((-1.0)*gconst14*x299*x331))+((x283*x284))+(((-2.31)*x295))+(((-1.0)*gconst2*x283*x334)));
op[5]=(((x305*x313))+(((-1.0)*x290*x340))+((x290*x296))+((x290*x299))+((x291*x329))+(((-1.5)*gconst7*x301))+(((-1.0)*x310*x316))+(((-1.0)*x281*x324))+(((-1.0)*x291*x337))+(((-1.0)*gconst1*x312))+(((-1.0)*x368))+(((-1.0)*x281*x340))+((x313*x329))+(((-1.0)*x371))+((x281*x296))+((x281*x299))+((x290*x330))+((x283*x290))+(((-1.0)*x282*x313))+(((-1.0)*gconst6*x356))+x353+x372+(((-1.0)*x281*x304))+((x320*x332))+((x286*x292))+((gconst3*x358))+(((-1.0)*x281*x333))+(((-1.0)*x298*x317))+((x295*x328))+(((-1.0)*x290*x324))+(((-1.0)*x282*x291))+(((2.9568)*x307)));
op[6]=(((gconst13*gconst6*x282))+(((-1.0)*gconst2*x305*x334))+((gconst2*gconst7*x301))+(((-1.0)*gconst14*x329*x331))+(((-1.0)*gconst0*x315))+(((-1.0)*x369))+(((-1.0)*x351))+((x296*x310))+((x299*x310))+((x284*x305))+((x284*x309))+(((-1.0)*gconst1*x303))+(((-1.0)*x309*x333))+(((-1.0)*x282*x298))+x349+(((-1.0)*gconst0*x300*x310))+(((-1.0)*gconst6*x299*x331))+(((-1.0)*x283*x355))+((x298*x329))+((gconst14*gconst5*x282))+(((-1.0)*x336*x357))+((x323*x336))+(((-1.0)*x282*x302))+((gconst1*x341))+((x292*x297))+(((-2.31)*x292)));
op[7]=(((x290*x329))+(((-1.0)*x310*x317))+((x290*x305))+((x292*x328))+(((-1.0)*x353))+((x281*x329))+(((-1.0)*x281*x282))+x371+(((-1.0)*x281*x337))+(((-1.0)*x282*x290)));
op[8]=(((x310*x329))+(((-1.0)*x354))+(((-1.0)*x282*x310))+((x282*x332))+(((-1.0)*x305*x355)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x373=((1.0)*r21);
IkReal x374=((7.9999999744e-5)*r20);
IkReal x375=(cj1*cj3);
IkReal x376=(cj5*sj4);
IkReal x377=(sj1*sj5);
IkReal x378=(cj4*r21);
IkReal x379=(cj4*r20);
IkReal x380=(cj1*sj5);
IkReal x381=(r22*sj1);
IkReal x382=((7.9999999744e-5)*sj3);
IkReal x383=((0.9999999968)*cj4);
IkReal x384=(cj1*r22);
IkReal x385=(cj1*cj5);
IkReal x386=(cj4*cj5*sj1);
IkReal x387=((1.0)*r20*sj4);
IkReal x388=((0.9999999968)*r21*sj3);
IkReal x389=((7.9999999744e-5)*r21*sj4);
IkReal x390=((0.9999999968)*r20*sj3);
IkReal x391=((0.9999999968)*cj3*r22*sj4);
if( IKabs((((x377*x388))+((cj3*x377*x389))+(((0.9999999968)*cj3*sj4*x381))+(((-1.0)*x380*x387))+(((-1.0)*x381*x382))+(((-1.0)*cj3*x373*x386))+(((-1.0)*cj5*sj1*x390))+(((-1.0)*cj3*x377*x379))+(((-1.0)*cj1*x373*x376))+(((-7.9999999744e-5)*x378*x380))+(((-1.0)*cj3*sj1*x374*x376))+(((-1.0)*x383*x384))+((cj4*x374*x385)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-7.9999999744e-5)*x377*x378))+((x385*x390))+(((-1.0)*x380*x388))+(((-1.0)*x381*x383))+((x374*x386))+(((-1.0)*sj1*x373*x376))+(((-0.9999999968)*r22*sj4*x375))+((cj5*x375*x378))+((x382*x384))+(((-1.0)*sj5*x375*x389))+(((-1.0)*x377*x387))+((x374*x375*x376))+((sj5*x375*x379)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x377*x388))+((cj3*x377*x389))+(((0.9999999968)*cj3*sj4*x381))+(((-1.0)*x380*x387))+(((-1.0)*x381*x382))+(((-1.0)*cj3*x373*x386))+(((-1.0)*cj5*sj1*x390))+(((-1.0)*cj3*x377*x379))+(((-1.0)*cj1*x373*x376))+(((-7.9999999744e-5)*x378*x380))+(((-1.0)*cj3*sj1*x374*x376))+(((-1.0)*x383*x384))+((cj4*x374*x385))))+IKsqr(((((-7.9999999744e-5)*x377*x378))+((x385*x390))+(((-1.0)*x380*x388))+(((-1.0)*x381*x383))+((x374*x386))+(((-1.0)*sj1*x373*x376))+(((-0.9999999968)*r22*sj4*x375))+((cj5*x375*x378))+((x382*x384))+(((-1.0)*sj5*x375*x389))+(((-1.0)*x377*x387))+((x374*x375*x376))+((sj5*x375*x379))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x377*x388))+((cj3*x377*x389))+(((0.9999999968)*cj3*sj4*x381))+(((-1.0)*x380*x387))+(((-1.0)*x381*x382))+(((-1.0)*cj3*x373*x386))+(((-1.0)*cj5*sj1*x390))+(((-1.0)*cj3*x377*x379))+(((-1.0)*cj1*x373*x376))+(((-7.9999999744e-5)*x378*x380))+(((-1.0)*cj3*sj1*x374*x376))+(((-1.0)*x383*x384))+((cj4*x374*x385))), ((((-7.9999999744e-5)*x377*x378))+((x385*x390))+(((-1.0)*x380*x388))+(((-1.0)*x381*x383))+((x374*x386))+(((-1.0)*sj1*x373*x376))+(((-0.9999999968)*r22*sj4*x375))+((cj5*x375*x378))+((x382*x384))+(((-1.0)*sj5*x375*x389))+(((-1.0)*x377*x387))+((x374*x375*x376))+((sj5*x375*x379))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x392=IKcos(j2);
IkReal x393=IKsin(j2);
IkReal x394=((0.12)*sj1);
IkReal x395=(r11*sj5);
IkReal x396=((0.9999999968)*sj3);
IkReal x397=(cj1*sj0);
IkReal x398=((0.9999999968)*cj4);
IkReal x399=(cj5*r00);
IkReal x400=(r21*sj5);
IkReal x401=((7.9999999744e-5)*cj4);
IkReal x402=((7.9999999744e-5)*sj3);
IkReal x403=(r01*sj5);
IkReal x404=(cj0*sj1);
IkReal x405=(cj0*cj1);
IkReal x406=(cj5*r10);
IkReal x407=((1.59999999488e-6)*sj4);
IkReal x408=((1.0)*sj4);
IkReal x409=(r20*sj5);
IkReal x410=(cj5*r21);
IkReal x411=((0.02)*cj4);
IkReal x412=(cj5*r20);
IkReal x413=(r10*sj5);
IkReal x414=(r00*sj5);
IkReal x415=(cj5*r01);
IkReal x416=((0.019999999936)*sj4);
IkReal x417=(cj5*r11);
IkReal x418=(cj0*x392);
IkReal x419=((0.76)*x392);
IkReal x420=((7.9999999744e-5)*cj3*sj4);
IkReal x421=((0.12)*x393);
IkReal x422=((1.0)*x393);
IkReal x423=(sj1*x392);
IkReal x424=((0.76)*x393);
IkReal x425=((1.0)*cj3*cj4);
IkReal x426=(cj1*x392);
IkReal x427=((0.9999999968)*cj3*sj4);
IkReal x428=(sj0*sj1*x393);
IkReal x429=(cj5*x425);
evalcond[0]=((((-1.0)*x423))+(((-1.0)*cj1*x422))+(((-1.0)*x400*x401))+(((-1.0)*r22*x398))+((x401*x412))+(((-1.0)*x408*x410))+(((-1.0)*x408*x409)));
evalcond[1]=(((x392*x405))+(((-1.0)*r02*x398))+(((-1.0)*x401*x403))+(((-1.0)*x404*x422))+((x399*x401))+(((-1.0)*x408*x415))+(((-1.0)*x408*x414)));
evalcond[2]=((((-1.0)*sj0*sj1*x422))+(((-1.0)*r12*x398))+(((-1.0)*x395*x401))+(((-1.0)*x408*x413))+(((-1.0)*x408*x417))+((x392*x397))+((x401*x406)));
evalcond[3]=((((-1.0)*x412*x420))+(((-1.0)*sj1*x422))+x426+((r22*x427))+(((-1.0)*x409*x425))+(((-1.0)*x396*x412))+(((-1.0)*x410*x425))+((x396*x400))+(((-1.0)*r22*x402))+((x400*x420)));
evalcond[4]=(((x403*x420))+((x393*x405))+((x392*x404))+(((-1.0)*r02*x402))+((r02*x427))+(((-1.0)*x399*x420))+(((-1.0)*x396*x399))+(((-1.0)*x414*x425))+(((-1.0)*x415*x425))+((x396*x403)));
evalcond[5]=(((x395*x396))+((x395*x420))+(((-1.0)*x406*x420))+(((-1.0)*x417*x425))+(((-1.0)*x396*x406))+(((-1.0)*x413*x425))+((r12*x427))+(((-1.0)*r12*x402))+((x393*x397))+((sj0*x423)));
evalcond[6]=(((x407*x412))+(((6.39999997952e-6)*x400))+(((-1.0)*cj1*x424))+(((0.65)*cj1))+((x410*x411))+(((-6.39999997952e-6)*x412))+((x409*x411))+(((0.12)*x426))+(((-1.0)*pz))+(((-1.0)*x400*x407))+(((0.01)*sj1))+(((-1.0)*sj1*x419))+(((-1.0)*r22*x416))+(((-1.0)*x393*x394)));
evalcond[7]=((((6.39999997952e-6)*x403))+(((-0.01)*x405))+((x405*x419))+((x411*x414))+((x411*x415))+(((-1.0)*r02*x416))+(((-1.0)*x403*x407))+((x405*x421))+(((-1.0)*px))+(((0.65)*x404))+(((-1.0)*x404*x424))+((x394*x418))+((x399*x407))+(((-6.39999997952e-6)*x399))+(((0.15)*cj0)));
evalcond[8]=((((6.39999997952e-6)*x395))+((sj0*x392*x394))+(((-0.01)*x397))+((x411*x413))+((x411*x417))+(((-6.39999997952e-6)*x406))+(((-1.0)*sj0*sj1*x424))+(((-1.0)*x395*x407))+(((-1.0)*py))+((x406*x407))+(((0.65)*sj0*sj1))+(((0.15)*sj0))+(((-1.0)*r12*x416))+((x397*x419))+((x397*x421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x430=((0.9999999968)*sj0);
IkReal x431=(cj5*r20);
IkReal x432=(r21*sj5);
IkReal x433=((7.9999999744e-5)*cj4);
IkReal x434=((1.0)*cj5);
IkReal x435=(cj4*sj0);
IkReal x436=((1.0)*sj5);
IkReal x437=((7.9999999744e-5)*sj0*sj4);
CheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign((((r10*((((cj5*x433))+(((-1.0)*sj4*x436))))))+(((-0.9999999968)*cj4*r12))+((r11*(((((-1.0)*sj5*x433))+(((-1.0)*sj4*x434)))))))),-1);
if(!x438.valid){
continue;
}
CheckValue<IkReal> x439 = IKatan2WithCheck(IkReal(((((-1.0)*x430*x431))+(((-7.9999999744e-5)*r22*sj0))+((x430*x432)))),IkReal(((((-1.0)*x431*x437))+(((-1.0)*r20*x435*x436))+(((-1.0)*r21*x434*x435))+((r22*sj4*x430))+((x432*x437)))),IKFAST_ATAN2_MAGTHRESH);
if(!x439.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x438.value)))+(x439.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x440=IKsin(j3);
IkReal x441=IKcos(j3);
IkReal x442=((7.9999999744e-5)*cj5);
IkReal x443=((7.9999999744e-5)*sj5);
IkReal x444=(sj4*x440);
IkReal x445=(cj4*x440);
IkReal x446=((0.9999999968)*x441);
IkReal x447=((7.9999999744e-5)*x441);
evalcond[0]=((((-1.0)*cj5*r20*x446))+((r20*sj5*x445))+((r20*x442*x444))+((r21*sj5*x446))+(((-0.9999999968)*r22*x444))+(((-1.0)*r22*x447))+((cj5*r21*x445))+(((-1.0)*r21*x443*x444)));
evalcond[1]=(((cj5*r11*x445))+(((-1.0)*cj5*r10*x446))+cj0+(((-1.0)*r12*x447))+(((-0.9999999968)*r12*x444))+((r10*x442*x444))+((r11*sj5*x446))+(((-1.0)*r11*x443*x444))+((r10*sj5*x445)));
evalcond[2]=((((-1.0)*sj0))+((r00*x442*x444))+(((-1.0)*cj5*r00*x446))+((cj5*r01*x445))+(((-0.9999999968)*r02*x444))+(((-1.0)*r02*x447))+((r01*sj5*x446))+((r00*sj5*x445))+(((-1.0)*r01*x443*x444)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x448=((0.02)*cj4);
IkReal x449=((7.9999999744e-5)*cj4);
IkReal x450=(sj4*sj5);
IkReal x451=(cj5*sj4);
IkReal x452=((0.9999999968)*cj4*r02);
IkReal x453=((6.39999997952e-6)*r21*sj5);
IkReal x454=(cj5*r00*x449);
IkReal x455=((1.0)*r01*x451);
IkReal x456=((1.0)*r00*x450);
IkReal x457=(r01*sj5*x449);
IkReal x458=(cj5*r21*x448);
IkReal x459=(r20*sj5*x448);
IkReal x460=((1.59999999488e-6)*r20*x451);
IkReal x461=((((0.019999999936)*r22*sj4))+(((6.39999997952e-6)*cj5*r20))+(((1.0)*pz))+(((1.59999999488e-6)*r21*x450)));
IkReal x462=(x458+x459+x453+x460);
IkReal x463=(x456+x457+x455+x452);
IkReal x464=(cj0+(((-1.0)*x463))+x454);
IkReal x465=((((-1.0)*x463))+x454+(((-1.0)*cj0)));
IkReal x466=((0.77)+(((-1.0)*x461))+x462);
IkReal x467=((0.53)+(((-1.0)*x461))+x462);
IkReal x468=((-0.77)+(((-1.0)*x461))+x462);
IkReal x469=((-0.53)+(((-1.0)*x461))+x462);
IkReal gconst0=x464;
IkReal gconst1=x465;
IkReal gconst2=x466;
IkReal gconst3=x467;
IkReal gconst4=x464;
IkReal gconst5=x465;
IkReal gconst6=x466;
IkReal gconst7=x467;
IkReal gconst8=x465;
IkReal gconst9=x464;
IkReal gconst10=x468;
IkReal gconst11=x469;
IkReal gconst12=x465;
IkReal gconst13=x464;
IkReal gconst14=x468;
IkReal gconst15=x469;
IkReal x470=cj0*cj0;
IkReal x471=((1.54)*gconst4);
IkReal x472=(gconst0*gconst3);
IkReal x473=(gconst6*gconst9);
IkReal x474=((1.92)*cj0);
IkReal x475=(gconst10*gconst9);
IkReal x476=((1.54)*gconst14);
IkReal x477=(gconst13*gconst8);
IkReal x478=((6.08)*cj0);
IkReal x479=(gconst12*gconst3);
IkReal x480=((1.5)*gconst5);
IkReal x481=((1.54)*gconst12);
IkReal x482=(gconst0*gconst5);
IkReal x483=(gconst0*gconst12);
IkReal x484=(gconst11*gconst14);
IkReal x485=(gconst0*gconst13);
IkReal x486=(gconst2*gconst9);
IkReal x487=(gconst11*gconst6);
IkReal x488=(gconst15*gconst4);
IkReal x489=(gconst1*gconst10);
IkReal x490=((1.0)*gconst11);
IkReal x491=(gconst1*gconst12);
IkReal x492=(gconst12*gconst7);
IkReal x493=((2.25)*gconst5);
IkReal x494=(gconst0*gconst15);
IkReal x495=(gconst1*gconst6);
IkReal x496=(gconst12*gconst15);
IkReal x497=(cj0*gconst4);
IkReal x498=((1.5)*gconst11);
IkReal x499=(gconst3*gconst4);
IkReal x500=(gconst4*gconst7);
IkReal x501=(gconst13*gconst14);
IkReal x502=((2.88)*cj0);
IkReal x503=((1.5)*gconst13);
IkReal x504=((2.25)*gconst13);
IkReal x505=((2.3716)*gconst4);
IkReal x506=((1.5)*gconst9);
IkReal x507=((1.5)*gconst1);
IkReal x508=(gconst11*gconst4);
IkReal x509=(gconst11*gconst8);
IkReal x510=((1.54)*gconst8);
IkReal x511=((2.3104)*gconst4);
IkReal x512=(gconst15*gconst8);
IkReal x513=(gconst5*gconst8);
IkReal x514=(gconst0*gconst11);
IkReal x515=(gconst14*gconst9);
IkReal x516=(gconst12*gconst9);
IkReal x517=(gconst11*gconst12);
IkReal x518=((1.54)*gconst6);
IkReal x519=(gconst1*gconst2);
IkReal x520=(gconst1*gconst14);
IkReal x521=((1.0)*gconst5);
IkReal x522=(gconst5*gconst6);
IkReal x523=(gconst7*gconst8);
IkReal x524=((1.0)*gconst13);
IkReal x525=(cj0*gconst12);
IkReal x526=(gconst3*gconst6);
IkReal x527=(gconst0*gconst7);
IkReal x528=(gconst14*gconst3);
IkReal x529=((9.12)*cj0);
IkReal x530=(gconst3*gconst8);
IkReal x531=((2.0804)*gconst4);
IkReal x532=((1.4592)*gconst4);
IkReal x533=((1.4592)*x516);
IkReal x534=((9.3632)*x525);
IkReal x535=((2.3104)*x516);
IkReal x536=(gconst9*x529);
IkReal x537=(gconst9*x532);
IkReal x538=((1.4592)*x491);
IkReal x539=((9.3632)*x497);
IkReal x540=((2.3104)*x491);
IkReal x541=(gconst1*x529);
IkReal x542=(gconst9*x511);
IkReal x543=(gconst1*x532);
IkReal x544=(gconst1*x511);
IkReal x545=(gconst2*x521);
IkReal x546=((24.64)*x470);
IkReal x547=((16.0)*x470);
IkReal x548=((24.0)*x470);
IkReal x549=(x478*x515);
IkReal x550=(x478*x517);
IkReal x551=(x478*x508);
IkReal x552=(x478*x520);
IkReal x553=(x473*x478);
IkReal x554=(x478*x479);
IkReal x555=(x478*x499);
IkReal x556=(x478*x495);
IkReal x557=(gconst14*x547);
IkReal x558=(x537+x538);
IkReal x559=(x540+x542);
IkReal x560=(x550+x549);
IkReal x561=(x556+x555);
IkReal x562=(x553+x552+x551+x554);
op[0]=((((-1.0)*gconst8*x490*x496))+((x475*x496))+(((-1.0)*x535))+(((-1.0)*x475*x501))+((x477*x484)));
op[1]=(((x475*x481))+((x475*x503))+(((-1.0)*x496*x506))+(((-1.0)*x481*x509))+((x501*x506))+x533+((x476*x477))+(((-1.0)*x477*x498))+(((-1.0)*x560))+(((-1.0)*x481*x512)));
op[2]=(((x474*x515))+((x474*x517))+((x484*x485))+(((-1.0)*gconst8*x490*x492))+((x475*x492))+(((-1.0)*gconst10*x473*x524))+(((-1.0)*gconst15*x483*x490))+((x489*x496))+((x475*x488))+(((2.0804)*x516))+(((-1.0)*x534))+((x477*x528))+(((-2.31)*x477))+(((-1.0)*x479*x512))+(((-1.0)*gconst8*x488*x490))+(((-1.0)*x559))+(((-1.0)*x489*x501))+x536+(((-1.0)*x486*x501))+((x486*x496))+(((-1.0)*gconst9*x504))+(((-1.0)*gconst14*x475*x521))+(((-1.0)*x484*x547))+(((-2.3716)*gconst12*gconst8))+((x477*x487))+((x484*x513)));
op[3]=(((x489*x503))+(((-1.5)*gconst3*x477))+((x471*x475))+(((-1.0)*x471*x509))+(((-1.0)*x488*x506))+(((-1.0)*gconst14*x546))+((x476*x485))+((x480*x515))+((x475*x480))+(((2.9568)*x525))+(((-1.0)*x533))+((x481*x489))+((x481*x486))+((x501*x507))+x558+x560+(((-1.0)*x480*x509))+((x476*x513))+(((-1.0)*x481*x494))+(((-1.0)*x492*x506))+((gconst11*x548))+(((-1.0)*x485*x498))+(((-1.0)*x471*x512))+(((-1.5)*gconst15*x491))+((x477*x518))+(((-1.0)*gconst9*x502))+((x486*x503))+(((-1.0)*x479*x510))+(((-1.0)*x481*x523))+(((-1.0)*x562))+(((-1.0)*x481*x514))+((x473*x503)));
op[4]=(((x485*x487))+((x487*x513))+(((-1.0)*gconst1*x504))+(((-1.0)*gconst10*x473*x521))+(((-1.0)*gconst7*x483*x490))+(((-1.0)*gconst14*x489*x521))+((x473*x474))+(((-1.0)*gconst2*x473*x524))+((x474*x520))+((x489*x492))+((x488*x489))+(((-1.0)*gconst14*x486*x521))+(((-2.31)*x485))+((x475*x500))+(((-1.0)*x501*x519))+(((-1.0)*x539))+(((-1.0)*x536))+(((-1.0)*x535))+((x474*x508))+(((-1.0)*x544))+(((-1.0)*gconst0*x488*x490))+((x477*x526))+((x513*x528))+(((-1.0)*x528*x547))+(((2.0804)*x491))+(((-1.0)*gconst6*x489*x524))+(((-2.3716)*x483))+(((-1.0)*x488*x530))+(((-2.31)*x513))+x541+x534+((x474*x479))+(((-1.0)*x479*x523))+((gconst9*x531))+((x482*x484))+((x486*x488))+((gconst15*gconst2*x491))+(((-1.0)*gconst8*x490*x500))+(((-1.0)*gconst9*x493))+((x486*x492))+(((36.96)*x470))+(((-1.0)*x472*x496))+(((-1.0)*gconst8*x505))+(((-1.0)*x487*x547))+((x472*x501)));
op[5]=(((x471*x486))+((x471*x489))+(((-1.0)*gconst1*x502))+(((-1.0)*x488*x507))+(((-1.0)*x480*x514))+((x481*x519))+((x476*x482))+((gconst3*x548))+(((-1.0)*x472*x503))+((x503*x519))+((x495*x503))+(((2.9568)*x497))+(((-1.0)*x558))+((x480*x486))+((x480*x489))+x543+x562+(((-1.5)*gconst7*x491))+((x510*x522))+(((-1.0)*x471*x514))+(((-1.0)*x480*x530))+((x480*x520))+(((-1.0)*x471*x530))+(((-1.0)*x481*x527))+((x473*x480))+(((-1.0)*x500*x506))+(((-1.0)*gconst6*x546))+(((-1.0)*x471*x523))+(((-1.0)*x471*x494))+(((-1.0)*x561))+(((-1.0)*x472*x481))+((x485*x518)));
op[6]=(((x489*x500))+(((-1.0)*x499*x523))+(((-1.0)*x526*x547))+(((-2.31)*x482))+((gconst14*gconst5*x472))+((gconst13*gconst6*x472))+(((-1.0)*x541))+((gconst2*gconst7*x491))+(((-1.0)*gconst0*x505))+(((-1.0)*x559))+((x513*x526))+(((-1.0)*gconst0*x490*x500))+(((-1.0)*gconst6*x489*x521))+(((-1.0)*gconst1*x493))+((gconst1*x531))+x539+(((-1.0)*x472*x488))+((x474*x495))+((x474*x499))+(((-1.0)*gconst14*x519*x521))+((x488*x519))+((x482*x487))+(((-1.0)*x473*x545))+(((-1.0)*gconst2*x495*x524))+((x486*x500))+(((-1.0)*x472*x492)));
op[7]=(((x480*x519))+((x471*x519))+(((-1.0)*x543))+((x480*x495))+x561+(((-1.0)*x471*x472))+((x482*x518))+(((-1.0)*x500*x507))+(((-1.0)*x471*x527))+(((-1.0)*x472*x480)));
op[8]=((((-1.0)*x495*x545))+(((-1.0)*x544))+((x500*x519))+(((-1.0)*x472*x500))+((x472*x522)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x563=((1.0)*r21);
IkReal x564=((7.9999999744e-5)*r20);
IkReal x565=(cj1*cj3);
IkReal x566=(cj5*sj4);
IkReal x567=(sj1*sj5);
IkReal x568=(cj4*r21);
IkReal x569=(cj4*r20);
IkReal x570=(cj1*sj5);
IkReal x571=(r22*sj1);
IkReal x572=((7.9999999744e-5)*sj3);
IkReal x573=((0.9999999968)*cj4);
IkReal x574=(cj1*r22);
IkReal x575=(cj1*cj5);
IkReal x576=(cj4*cj5*sj1);
IkReal x577=((1.0)*r20*sj4);
IkReal x578=((0.9999999968)*r21*sj3);
IkReal x579=((7.9999999744e-5)*r21*sj4);
IkReal x580=((0.9999999968)*r20*sj3);
IkReal x581=((0.9999999968)*cj3*r22*sj4);
if( IKabs(((((-1.0)*cj5*sj1*x580))+((cj3*x567*x579))+((x567*x578))+(((-1.0)*x573*x574))+(((-1.0)*x570*x577))+(((0.9999999968)*cj3*sj4*x571))+(((-1.0)*x571*x572))+((cj4*x564*x575))+(((-1.0)*cj3*x563*x576))+(((-7.9999999744e-5)*x568*x570))+(((-1.0)*cj1*x563*x566))+(((-1.0)*cj3*x567*x569))+(((-1.0)*cj3*sj1*x564*x566)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj5*x565*x579))+(((-0.9999999968)*r22*sj4*x565))+(((-1.0)*x570*x578))+(((-7.9999999744e-5)*x567*x568))+(((-1.0)*x571*x573))+((x564*x565*x566))+((sj5*x565*x569))+((x575*x580))+((x564*x576))+(((-1.0)*x567*x577))+((cj5*x565*x568))+((x572*x574))+(((-1.0)*sj1*x563*x566)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj5*sj1*x580))+((cj3*x567*x579))+((x567*x578))+(((-1.0)*x573*x574))+(((-1.0)*x570*x577))+(((0.9999999968)*cj3*sj4*x571))+(((-1.0)*x571*x572))+((cj4*x564*x575))+(((-1.0)*cj3*x563*x576))+(((-7.9999999744e-5)*x568*x570))+(((-1.0)*cj1*x563*x566))+(((-1.0)*cj3*x567*x569))+(((-1.0)*cj3*sj1*x564*x566))))+IKsqr(((((-1.0)*sj5*x565*x579))+(((-0.9999999968)*r22*sj4*x565))+(((-1.0)*x570*x578))+(((-7.9999999744e-5)*x567*x568))+(((-1.0)*x571*x573))+((x564*x565*x566))+((sj5*x565*x569))+((x575*x580))+((x564*x576))+(((-1.0)*x567*x577))+((cj5*x565*x568))+((x572*x574))+(((-1.0)*sj1*x563*x566))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj5*sj1*x580))+((cj3*x567*x579))+((x567*x578))+(((-1.0)*x573*x574))+(((-1.0)*x570*x577))+(((0.9999999968)*cj3*sj4*x571))+(((-1.0)*x571*x572))+((cj4*x564*x575))+(((-1.0)*cj3*x563*x576))+(((-7.9999999744e-5)*x568*x570))+(((-1.0)*cj1*x563*x566))+(((-1.0)*cj3*x567*x569))+(((-1.0)*cj3*sj1*x564*x566))), ((((-1.0)*sj5*x565*x579))+(((-0.9999999968)*r22*sj4*x565))+(((-1.0)*x570*x578))+(((-7.9999999744e-5)*x567*x568))+(((-1.0)*x571*x573))+((x564*x565*x566))+((sj5*x565*x569))+((x575*x580))+((x564*x576))+(((-1.0)*x567*x577))+((cj5*x565*x568))+((x572*x574))+(((-1.0)*sj1*x563*x566))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x582=IKcos(j2);
IkReal x583=IKsin(j2);
IkReal x584=((0.12)*sj1);
IkReal x585=(r11*sj5);
IkReal x586=((0.9999999968)*sj3);
IkReal x587=(cj1*sj0);
IkReal x588=((0.9999999968)*cj4);
IkReal x589=(cj5*r00);
IkReal x590=(r21*sj5);
IkReal x591=((7.9999999744e-5)*cj4);
IkReal x592=((7.9999999744e-5)*sj3);
IkReal x593=(r01*sj5);
IkReal x594=(cj0*sj1);
IkReal x595=(cj0*cj1);
IkReal x596=(cj5*r10);
IkReal x597=((1.59999999488e-6)*sj4);
IkReal x598=((1.0)*sj4);
IkReal x599=(r20*sj5);
IkReal x600=(cj5*r21);
IkReal x601=((0.02)*cj4);
IkReal x602=(cj5*r20);
IkReal x603=(r10*sj5);
IkReal x604=(r00*sj5);
IkReal x605=(cj5*r01);
IkReal x606=((0.019999999936)*sj4);
IkReal x607=(cj5*r11);
IkReal x608=(cj0*x582);
IkReal x609=((0.76)*x582);
IkReal x610=((7.9999999744e-5)*cj3*sj4);
IkReal x611=((0.12)*x583);
IkReal x612=((1.0)*x583);
IkReal x613=(sj1*x582);
IkReal x614=((0.76)*x583);
IkReal x615=((1.0)*cj3*cj4);
IkReal x616=(cj1*x582);
IkReal x617=((0.9999999968)*cj3*sj4);
IkReal x618=(sj0*sj1*x583);
IkReal x619=(cj5*x615);
evalcond[0]=((((-1.0)*r22*x588))+(((-1.0)*x598*x599))+(((-1.0)*cj1*x612))+((x591*x602))+(((-1.0)*x590*x591))+(((-1.0)*x613))+(((-1.0)*x598*x600)));
evalcond[1]=((((-1.0)*r02*x588))+(((-1.0)*x594*x612))+(((-1.0)*x598*x604))+(((-1.0)*x598*x605))+((x582*x595))+((x589*x591))+(((-1.0)*x591*x593)));
evalcond[2]=(((x582*x587))+(((-1.0)*x585*x591))+(((-1.0)*x598*x607))+(((-1.0)*x598*x603))+(((-1.0)*r12*x588))+((x591*x596))+(((-1.0)*sj0*sj1*x612)));
evalcond[3]=((((-1.0)*sj1*x612))+(((-1.0)*x586*x602))+(((-1.0)*x599*x615))+((x590*x610))+(((-1.0)*r22*x592))+x616+(((-1.0)*x600*x615))+((r22*x617))+((x586*x590))+(((-1.0)*x602*x610)));
evalcond[4]=((((-1.0)*x589*x610))+((x593*x610))+(((-1.0)*x586*x589))+(((-1.0)*x605*x615))+(((-1.0)*x604*x615))+((x583*x595))+((r02*x617))+(((-1.0)*r02*x592))+((x582*x594))+((x586*x593)));
evalcond[5]=(((x583*x587))+(((-1.0)*x586*x596))+((sj0*x613))+(((-1.0)*r12*x592))+(((-1.0)*x596*x610))+((x585*x586))+((r12*x617))+(((-1.0)*x607*x615))+((x585*x610))+(((-1.0)*x603*x615)));
evalcond[6]=((((6.39999997952e-6)*x590))+(((0.65)*cj1))+(((-1.0)*sj1*x609))+((x600*x601))+(((-1.0)*r22*x606))+(((-1.0)*cj1*x614))+((x597*x602))+(((-1.0)*x583*x584))+(((-1.0)*x590*x597))+(((-1.0)*pz))+(((0.12)*x616))+(((-6.39999997952e-6)*x602))+((x599*x601))+(((0.01)*sj1)));
evalcond[7]=(((x584*x608))+(((6.39999997952e-6)*x593))+(((0.65)*x594))+(((-1.0)*x594*x614))+(((-0.01)*x595))+((x601*x604))+((x601*x605))+((x595*x609))+((x595*x611))+(((-1.0)*px))+(((-1.0)*x593*x597))+(((-6.39999997952e-6)*x589))+(((-1.0)*r02*x606))+(((0.15)*cj0))+((x589*x597)));
evalcond[8]=(((sj0*x582*x584))+((x601*x607))+((x601*x603))+(((-6.39999997952e-6)*x596))+(((-1.0)*x585*x597))+((x587*x611))+(((-1.0)*py))+(((6.39999997952e-6)*x585))+(((-1.0)*r12*x606))+(((-0.01)*x587))+((x596*x597))+((x587*x609))+(((0.65)*sj0*sj1))+(((0.15)*sj0))+(((-1.0)*sj0*sj1*x614)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x620=(sj4*sj5);
IkReal x621=(cj0*r21);
IkReal x622=((0.9999999968)*cj0);
IkReal x623=(cj4*cj5);
IkReal x624=(cj5*r20);
IkReal x625=((7.9999999744e-5)*cj0);
IkReal x626=(cj4*sj5);
CheckValue<IkReal> x627=IKPowWithIntegerCheck(IKsign((((r00*(((((7.9999999744e-5)*x623))+(((-1.0)*x620))))))+((r01*(((((-1.0)*cj5*sj4))+(((-7.9999999744e-5)*x626))))))+(((-0.9999999968)*cj4*r02)))),-1);
if(!x627.valid){
continue;
}
CheckValue<IkReal> x628 = IKatan2WithCheck(IkReal(((((-1.0)*x622*x624))+(((0.9999999968)*sj5*x621))+(((-1.0)*r22*x625)))),IkReal((((r22*sj4*x622))+(((7.9999999744e-5)*x620*x621))+(((-1.0)*x621*x623))+(((-1.0)*cj0*r20*x626))+(((-1.0)*sj4*x624*x625)))),IKFAST_ATAN2_MAGTHRESH);
if(!x628.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x627.value)))+(x628.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x629=IKsin(j3);
IkReal x630=IKcos(j3);
IkReal x631=((7.9999999744e-5)*cj5);
IkReal x632=((7.9999999744e-5)*sj5);
IkReal x633=(sj4*x629);
IkReal x634=(cj4*x629);
IkReal x635=((0.9999999968)*x630);
IkReal x636=((7.9999999744e-5)*x630);
evalcond[0]=(((r20*sj5*x634))+((r21*sj5*x635))+(((-1.0)*cj5*r20*x635))+(((-1.0)*r21*x632*x633))+((cj5*r21*x634))+(((-0.9999999968)*r22*x633))+(((-1.0)*r22*x636))+((r20*x631*x633)));
evalcond[1]=((((-1.0)*r11*x632*x633))+cj0+((r10*sj5*x634))+(((-0.9999999968)*r12*x633))+(((-1.0)*r12*x636))+((cj5*r11*x634))+((r10*x631*x633))+(((-1.0)*cj5*r10*x635))+((r11*sj5*x635)));
evalcond[2]=((((-1.0)*cj5*r00*x635))+(((-1.0)*sj0))+((r00*x631*x633))+(((-1.0)*r02*x636))+(((-1.0)*r01*x632*x633))+((cj5*r01*x634))+(((-0.9999999968)*r02*x633))+((r01*sj5*x635))+((r00*sj5*x634)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[8+1], zeror[8];
int numroots;
IkReal x637=((0.02)*cj4);
IkReal x638=((7.9999999744e-5)*cj4);
IkReal x639=(sj4*sj5);
IkReal x640=(cj5*sj4);
IkReal x641=((0.9999999968)*cj4*r02);
IkReal x642=((6.39999997952e-6)*r21*sj5);
IkReal x643=(cj5*r00*x638);
IkReal x644=((1.0)*r01*x640);
IkReal x645=((1.0)*r00*x639);
IkReal x646=(r01*sj5*x638);
IkReal x647=(cj5*r21*x637);
IkReal x648=(r20*sj5*x637);
IkReal x649=((1.59999999488e-6)*r20*x640);
IkReal x650=((((0.019999999936)*r22*sj4))+(((6.39999997952e-6)*cj5*r20))+(((1.0)*pz))+(((1.59999999488e-6)*r21*x639)));
IkReal x651=(x647+x642+x649+x648);
IkReal x652=(x646+x645+x644+x641);
IkReal x653=(cj0+(((-1.0)*x652))+x643);
IkReal x654=((((-1.0)*x652))+x643+(((-1.0)*cj0)));
IkReal x655=((0.77)+(((-1.0)*x650))+x651);
IkReal x656=((0.53)+(((-1.0)*x650))+x651);
IkReal x657=((-0.77)+(((-1.0)*x650))+x651);
IkReal x658=((-0.53)+(((-1.0)*x650))+x651);
IkReal gconst0=x653;
IkReal gconst1=x654;
IkReal gconst2=x655;
IkReal gconst3=x656;
IkReal gconst4=x653;
IkReal gconst5=x654;
IkReal gconst6=x655;
IkReal gconst7=x656;
IkReal gconst8=x654;
IkReal gconst9=x653;
IkReal gconst10=x657;
IkReal gconst11=x658;
IkReal gconst12=x654;
IkReal gconst13=x653;
IkReal gconst14=x657;
IkReal gconst15=x658;
IkReal x659=cj0*cj0;
IkReal x660=((1.54)*gconst4);
IkReal x661=(gconst0*gconst3);
IkReal x662=(gconst6*gconst9);
IkReal x663=((1.92)*cj0);
IkReal x664=(gconst10*gconst9);
IkReal x665=((1.54)*gconst14);
IkReal x666=(gconst13*gconst8);
IkReal x667=((6.08)*cj0);
IkReal x668=(gconst12*gconst3);
IkReal x669=((1.5)*gconst5);
IkReal x670=((1.54)*gconst12);
IkReal x671=(gconst0*gconst5);
IkReal x672=(gconst0*gconst12);
IkReal x673=(gconst11*gconst14);
IkReal x674=(gconst0*gconst13);
IkReal x675=(gconst2*gconst9);
IkReal x676=(gconst11*gconst6);
IkReal x677=(gconst15*gconst4);
IkReal x678=(gconst1*gconst10);
IkReal x679=((1.0)*gconst11);
IkReal x680=(gconst1*gconst12);
IkReal x681=(gconst12*gconst7);
IkReal x682=((2.25)*gconst5);
IkReal x683=(gconst0*gconst15);
IkReal x684=(gconst1*gconst6);
IkReal x685=(gconst12*gconst15);
IkReal x686=(cj0*gconst4);
IkReal x687=((1.5)*gconst11);
IkReal x688=(gconst3*gconst4);
IkReal x689=(gconst4*gconst7);
IkReal x690=(gconst13*gconst14);
IkReal x691=((2.88)*cj0);
IkReal x692=((1.5)*gconst13);
IkReal x693=((2.25)*gconst13);
IkReal x694=((2.3716)*gconst4);
IkReal x695=((1.5)*gconst9);
IkReal x696=((1.5)*gconst1);
IkReal x697=(gconst11*gconst4);
IkReal x698=(gconst11*gconst8);
IkReal x699=((1.54)*gconst8);
IkReal x700=((2.3104)*gconst4);
IkReal x701=(gconst15*gconst8);
IkReal x702=(gconst5*gconst8);
IkReal x703=(gconst0*gconst11);
IkReal x704=(gconst14*gconst9);
IkReal x705=(gconst12*gconst9);
IkReal x706=(gconst11*gconst12);
IkReal x707=((1.54)*gconst6);
IkReal x708=(gconst1*gconst2);
IkReal x709=(gconst1*gconst14);
IkReal x710=((1.0)*gconst5);
IkReal x711=(gconst5*gconst6);
IkReal x712=(gconst7*gconst8);
IkReal x713=((1.0)*gconst13);
IkReal x714=(cj0*gconst12);
IkReal x715=(gconst3*gconst6);
IkReal x716=(gconst0*gconst7);
IkReal x717=(gconst14*gconst3);
IkReal x718=((9.12)*cj0);
IkReal x719=(gconst3*gconst8);
IkReal x720=((2.0804)*gconst4);
IkReal x721=((1.4592)*gconst4);
IkReal x722=((1.4592)*x705);
IkReal x723=((9.3632)*x714);
IkReal x724=((2.3104)*x705);
IkReal x725=(gconst9*x718);
IkReal x726=(gconst9*x721);
IkReal x727=((1.4592)*x680);
IkReal x728=((9.3632)*x686);
IkReal x729=((2.3104)*x680);
IkReal x730=(gconst1*x718);
IkReal x731=(gconst9*x700);
IkReal x732=(gconst1*x721);
IkReal x733=(gconst1*x700);
IkReal x734=(gconst2*x710);
IkReal x735=((24.64)*x659);
IkReal x736=((16.0)*x659);
IkReal x737=((24.0)*x659);
IkReal x738=(x667*x704);
IkReal x739=(x667*x706);
IkReal x740=(x667*x697);
IkReal x741=(x667*x709);
IkReal x742=(x662*x667);
IkReal x743=(x667*x668);
IkReal x744=(x667*x688);
IkReal x745=(x667*x684);
IkReal x746=(gconst14*x736);
IkReal x747=(x726+x727);
IkReal x748=(x731+x729);
IkReal x749=(x739+x738);
IkReal x750=(x744+x745);
IkReal x751=(x742+x743+x740+x741);
op[0]=((((-1.0)*gconst8*x679*x685))+(((-1.0)*x724))+(((-1.0)*x664*x690))+((x666*x673))+((x664*x685)));
op[1]=((((-1.0)*x666*x687))+((x665*x666))+((x690*x695))+((x664*x670))+(((-1.0)*x685*x695))+(((-1.0)*x670*x698))+x722+((x664*x692))+(((-1.0)*x749))+(((-1.0)*x670*x701)));
op[2]=(((x673*x674))+(((-1.0)*gconst10*x662*x713))+((x678*x685))+(((-1.0)*x678*x690))+((x664*x677))+(((-1.0)*gconst15*x672*x679))+(((-1.0)*gconst14*x664*x710))+(((2.0804)*x705))+(((-1.0)*x668*x701))+(((-2.31)*x666))+(((-1.0)*gconst8*x679*x681))+(((-1.0)*x723))+((x673*x702))+((x666*x676))+((x666*x717))+(((-1.0)*gconst9*x693))+((x664*x681))+(((-1.0)*x673*x736))+((x663*x704))+((x663*x706))+x725+((x675*x685))+(((-1.0)*x748))+(((-1.0)*gconst8*x677*x679))+(((-1.0)*x675*x690))+(((-2.3716)*gconst12*gconst8)));
op[3]=((((-1.0)*x668*x699))+((x665*x674))+(((-1.0)*x670*x683))+((x664*x669))+((x690*x696))+((x669*x704))+((x670*x678))+((x670*x675))+(((-1.0)*x660*x698))+(((-1.5)*gconst3*x666))+((x675*x692))+(((-1.0)*x722))+(((-1.0)*x669*x698))+((x666*x707))+(((-1.0)*x677*x695))+(((-1.5)*gconst15*x680))+((x660*x664))+(((-1.0)*gconst9*x691))+(((-1.0)*gconst14*x735))+(((-1.0)*x674*x687))+((x662*x692))+x747+x749+((x665*x702))+(((2.9568)*x714))+(((-1.0)*x670*x712))+(((-1.0)*x751))+(((-1.0)*x681*x695))+(((-1.0)*x670*x703))+(((-1.0)*x660*x701))+((gconst11*x737))+((x678*x692)));
op[4]=((((-1.0)*gconst10*x662*x710))+((x678*x681))+(((-1.0)*gconst0*x677*x679))+(((-1.0)*gconst9*x682))+(((-1.0)*gconst1*x693))+(((-1.0)*gconst6*x678*x713))+((x671*x673))+(((-1.0)*gconst7*x672*x679))+((x702*x717))+(((-1.0)*gconst2*x662*x713))+((x662*x663))+(((-1.0)*x690*x708))+((x676*x702))+((x674*x676))+((x663*x668))+(((36.96)*x659))+((gconst9*x720))+((x661*x690))+((x677*x678))+((gconst15*gconst2*x680))+(((-1.0)*x717*x736))+(((-1.0)*x668*x712))+(((-1.0)*gconst8*x679*x689))+(((-1.0)*x728))+(((-1.0)*x725))+(((-1.0)*x724))+(((-1.0)*gconst8*x694))+(((-1.0)*x733))+(((-1.0)*x661*x685))+((x666*x715))+(((-2.31)*x702))+((x664*x689))+(((-1.0)*x676*x736))+(((-2.31)*x674))+((x663*x697))+((x663*x709))+(((-1.0)*gconst14*x675*x710))+x730+x723+(((-1.0)*x677*x719))+((x675*x681))+((x675*x677))+(((-2.3716)*x672))+(((2.0804)*x680))+(((-1.0)*gconst14*x678*x710)));
op[5]=((((-1.0)*x660*x719))+(((-1.0)*x660*x712))+((x660*x675))+((x660*x678))+((x670*x708))+((x665*x671))+(((-1.0)*gconst1*x691))+(((-1.0)*x669*x703))+((x674*x707))+(((-1.0)*x661*x692))+(((-1.0)*x669*x719))+((x662*x669))+((x684*x692))+((x669*x709))+(((2.9568)*x686))+((x692*x708))+(((-1.5)*gconst7*x680))+((x669*x675))+((x669*x678))+(((-1.0)*x660*x683))+(((-1.0)*x677*x696))+(((-1.0)*gconst6*x735))+x732+x751+(((-1.0)*x689*x695))+((gconst3*x737))+(((-1.0)*x747))+(((-1.0)*x670*x716))+(((-1.0)*x750))+((x699*x711))+(((-1.0)*x661*x670))+(((-1.0)*x660*x703)));
op[6]=((((-1.0)*x688*x712))+((x663*x684))+((x663*x688))+((x678*x689))+(((-1.0)*gconst6*x678*x710))+((x671*x676))+((x702*x715))+(((-1.0)*gconst0*x694))+((gconst1*x720))+((x677*x708))+(((-1.0)*x730))+(((-1.0)*x661*x681))+(((-1.0)*gconst1*x682))+(((-1.0)*gconst2*x684*x713))+(((-2.31)*x671))+(((-1.0)*x662*x734))+(((-1.0)*gconst14*x708*x710))+((gconst13*gconst6*x661))+(((-1.0)*x715*x736))+x728+((x675*x689))+(((-1.0)*x748))+((gconst2*gconst7*x680))+(((-1.0)*x661*x677))+(((-1.0)*gconst0*x679*x689))+((gconst14*gconst5*x661)));
op[7]=(((x660*x708))+((x669*x684))+(((-1.0)*x660*x716))+((x671*x707))+(((-1.0)*x660*x661))+((x669*x708))+(((-1.0)*x661*x669))+(((-1.0)*x732))+x750+(((-1.0)*x689*x696)));
op[8]=(((x661*x711))+((x689*x708))+(((-1.0)*x733))+(((-1.0)*x661*x689))+(((-1.0)*x684*x734)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x752=((1.0)*r21);
IkReal x753=((7.9999999744e-5)*r20);
IkReal x754=(cj1*cj3);
IkReal x755=(cj5*sj4);
IkReal x756=(sj1*sj5);
IkReal x757=(cj4*r21);
IkReal x758=(cj4*r20);
IkReal x759=(cj1*sj5);
IkReal x760=(r22*sj1);
IkReal x761=((7.9999999744e-5)*sj3);
IkReal x762=((0.9999999968)*cj4);
IkReal x763=(cj1*r22);
IkReal x764=(cj1*cj5);
IkReal x765=(cj4*cj5*sj1);
IkReal x766=((1.0)*r20*sj4);
IkReal x767=((0.9999999968)*r21*sj3);
IkReal x768=((7.9999999744e-5)*r21*sj4);
IkReal x769=((0.9999999968)*r20*sj3);
IkReal x770=((0.9999999968)*cj3*r22*sj4);
if( IKabs(((((-1.0)*x762*x763))+((cj3*x756*x768))+(((-7.9999999744e-5)*x757*x759))+(((-1.0)*cj3*x752*x765))+(((-1.0)*cj1*x752*x755))+((cj4*x753*x764))+((x756*x767))+(((-1.0)*cj5*sj1*x769))+(((0.9999999968)*cj3*sj4*x760))+(((-1.0)*cj3*sj1*x753*x755))+(((-1.0)*x760*x761))+(((-1.0)*cj3*x756*x758))+(((-1.0)*x759*x766)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj5*x754*x768))+((x753*x754*x755))+((sj5*x754*x758))+(((-1.0)*x756*x766))+(((-1.0)*sj1*x752*x755))+((x761*x763))+((cj5*x754*x757))+(((-0.9999999968)*r22*sj4*x754))+(((-1.0)*x760*x762))+((x753*x765))+((x764*x769))+(((-1.0)*x759*x767))+(((-7.9999999744e-5)*x756*x757)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x762*x763))+((cj3*x756*x768))+(((-7.9999999744e-5)*x757*x759))+(((-1.0)*cj3*x752*x765))+(((-1.0)*cj1*x752*x755))+((cj4*x753*x764))+((x756*x767))+(((-1.0)*cj5*sj1*x769))+(((0.9999999968)*cj3*sj4*x760))+(((-1.0)*cj3*sj1*x753*x755))+(((-1.0)*x760*x761))+(((-1.0)*cj3*x756*x758))+(((-1.0)*x759*x766))))+IKsqr(((((-1.0)*sj5*x754*x768))+((x753*x754*x755))+((sj5*x754*x758))+(((-1.0)*x756*x766))+(((-1.0)*sj1*x752*x755))+((x761*x763))+((cj5*x754*x757))+(((-0.9999999968)*r22*sj4*x754))+(((-1.0)*x760*x762))+((x753*x765))+((x764*x769))+(((-1.0)*x759*x767))+(((-7.9999999744e-5)*x756*x757))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x762*x763))+((cj3*x756*x768))+(((-7.9999999744e-5)*x757*x759))+(((-1.0)*cj3*x752*x765))+(((-1.0)*cj1*x752*x755))+((cj4*x753*x764))+((x756*x767))+(((-1.0)*cj5*sj1*x769))+(((0.9999999968)*cj3*sj4*x760))+(((-1.0)*cj3*sj1*x753*x755))+(((-1.0)*x760*x761))+(((-1.0)*cj3*x756*x758))+(((-1.0)*x759*x766))), ((((-1.0)*sj5*x754*x768))+((x753*x754*x755))+((sj5*x754*x758))+(((-1.0)*x756*x766))+(((-1.0)*sj1*x752*x755))+((x761*x763))+((cj5*x754*x757))+(((-0.9999999968)*r22*sj4*x754))+(((-1.0)*x760*x762))+((x753*x765))+((x764*x769))+(((-1.0)*x759*x767))+(((-7.9999999744e-5)*x756*x757))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x771=IKcos(j2);
IkReal x772=IKsin(j2);
IkReal x773=((0.12)*sj1);
IkReal x774=(r11*sj5);
IkReal x775=((0.9999999968)*sj3);
IkReal x776=(cj1*sj0);
IkReal x777=((0.9999999968)*cj4);
IkReal x778=(cj5*r00);
IkReal x779=(r21*sj5);
IkReal x780=((7.9999999744e-5)*cj4);
IkReal x781=((7.9999999744e-5)*sj3);
IkReal x782=(r01*sj5);
IkReal x783=(cj0*sj1);
IkReal x784=(cj0*cj1);
IkReal x785=(cj5*r10);
IkReal x786=((1.59999999488e-6)*sj4);
IkReal x787=((1.0)*sj4);
IkReal x788=(r20*sj5);
IkReal x789=(cj5*r21);
IkReal x790=((0.02)*cj4);
IkReal x791=(cj5*r20);
IkReal x792=(r10*sj5);
IkReal x793=(r00*sj5);
IkReal x794=(cj5*r01);
IkReal x795=((0.019999999936)*sj4);
IkReal x796=(cj5*r11);
IkReal x797=(cj0*x771);
IkReal x798=((0.76)*x771);
IkReal x799=((7.9999999744e-5)*cj3*sj4);
IkReal x800=((0.12)*x772);
IkReal x801=((1.0)*x772);
IkReal x802=(sj1*x771);
IkReal x803=((0.76)*x772);
IkReal x804=((1.0)*cj3*cj4);
IkReal x805=(cj1*x771);
IkReal x806=((0.9999999968)*cj3*sj4);
IkReal x807=(sj0*sj1*x772);
IkReal x808=(cj5*x804);
evalcond[0]=((((-1.0)*x802))+(((-1.0)*cj1*x801))+(((-1.0)*r22*x777))+(((-1.0)*x787*x789))+(((-1.0)*x787*x788))+((x780*x791))+(((-1.0)*x779*x780)));
evalcond[1]=(((x778*x780))+(((-1.0)*x787*x794))+(((-1.0)*x787*x793))+(((-1.0)*r02*x777))+((x771*x784))+(((-1.0)*x780*x782))+(((-1.0)*x783*x801)));
evalcond[2]=(((x771*x776))+(((-1.0)*r12*x777))+(((-1.0)*x787*x796))+(((-1.0)*x787*x792))+(((-1.0)*sj0*sj1*x801))+((x780*x785))+(((-1.0)*x774*x780)));
evalcond[3]=((((-1.0)*sj1*x801))+(((-1.0)*x775*x791))+((x779*x799))+((r22*x806))+(((-1.0)*x791*x799))+(((-1.0)*x789*x804))+(((-1.0)*x788*x804))+(((-1.0)*r22*x781))+x805+((x775*x779)));
evalcond[4]=(((x782*x799))+((x775*x782))+(((-1.0)*x793*x804))+((r02*x806))+(((-1.0)*x775*x778))+(((-1.0)*x794*x804))+((x772*x784))+(((-1.0)*x778*x799))+((x771*x783))+(((-1.0)*r02*x781)));
evalcond[5]=(((x774*x775))+(((-1.0)*x796*x804))+((x774*x799))+(((-1.0)*x775*x785))+((x772*x776))+((r12*x806))+(((-1.0)*r12*x781))+((sj0*x802))+(((-1.0)*x792*x804))+(((-1.0)*x785*x799)));
evalcond[6]=(((x786*x791))+(((0.65)*cj1))+(((-1.0)*cj1*x803))+(((0.12)*x805))+((x788*x790))+(((-6.39999997952e-6)*x791))+(((-1.0)*pz))+(((6.39999997952e-6)*x779))+(((-1.0)*x772*x773))+(((-1.0)*r22*x795))+(((0.01)*sj1))+((x789*x790))+(((-1.0)*sj1*x798))+(((-1.0)*x779*x786)));
evalcond[7]=(((x773*x797))+(((0.65)*x783))+((x790*x793))+((x790*x794))+(((-1.0)*px))+((x778*x786))+((x784*x798))+(((-6.39999997952e-6)*x778))+(((-1.0)*x782*x786))+(((6.39999997952e-6)*x782))+(((0.15)*cj0))+(((-1.0)*r02*x795))+((x784*x800))+(((-1.0)*x783*x803))+(((-0.01)*x784)));
evalcond[8]=(((x785*x786))+((x790*x792))+((x790*x796))+(((-6.39999997952e-6)*x785))+(((-1.0)*r12*x795))+(((-1.0)*py))+(((6.39999997952e-6)*x774))+((sj0*x771*x773))+(((-1.0)*sj0*sj1*x803))+(((-0.01)*x776))+(((-1.0)*x774*x786))+((x776*x800))+(((0.65)*sj0*sj1))+(((0.15)*sj0))+((x776*x798)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - 1410_URDF (0cf2a3592a24a82a2d11c9200604c1ce)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
